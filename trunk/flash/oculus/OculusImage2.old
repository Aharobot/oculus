package oculus
{
	//	import flash.display.BitmapData;
	import flash.utils.ByteArray;
	
	public class OculusImage 
	{
		private var parr:Array = []; // working pixels, whole image, 8-bit greyscale 
		private var lastparr:Array=[];
		private var width:int;
		private var height:int;
		private var lastblob:Array = []; // devel only
		private var lastThreshhold:int;
		private var threshholdMult:Number = 0.65;
		private var lastblobSize:int;
		private var lastBlobRatio:Number;
		private var lastTopRatio:Number;
		private var lastBottomRatio:Number;
		
		public function OculusImage()
		{
		}
		
		public function convertToGrey(pixelRGB:ByteArray):void {
			// uses 30-59-11 RGB weighting from: http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
			var p:int;
			var n:int = 0;
			//var runningttl:int = 0;			
			parr = [];
			for (var i:int=0; i < pixelRGB.length; i+=4) {
				p = pixelRGB[i+1]*0.3 + pixelRGB[i+2]*0.59 + pixelRGB[i+3]*0.11 ;
				parr[n]=p;
				n++;
				//runningttl += p;
			}
			//imgaverage = runningttl/pixelRGB.length;
			lastparr=parr.slice();  // maybe devel only, remove if unused
		}
		
		public function processedImage():ByteArray {
			var newPixels:ByteArray = new ByteArray();
			var n:int = 0;
			var p:int;
			for each (var i:Boolean in parr) {
				if (i) { p=255; }
				else { p=0; }
				newPixels[n]=255;
				newPixels[n+1]=p;
				newPixels[n+2]=p;
				newPixels[n+3]=p;
				n+=4;
			}
			return newPixels;		
		}
		
		public function blobOverlay():ByteArray {
			var newPixels:ByteArray = new ByteArray();
			var n:int = 0;
			var i:int;
			for each (i in lastparr) {
				newPixels[n]=255;
				newPixels[n+1]=i; 
				newPixels[n+2]=i;
				newPixels[n+3]=i;
				n+=4;
			}
			for (n=0;n<lastblob.length;n++) {
				if (lastblob[n]) {
					newPixels[(n*4)+1]=255; // red
				}
			}
			return newPixels;		
		}
		
		public function colorTest(argb:ByteArray):ByteArray {
			var a:ByteArray = new ByteArray;
			var th:int = 128;
			var p:int;
			var f:int = 1.1;
			var red:int;
			var green:int;
			var blue:int;
			for (var i:int=0; i < argb.length; i+=4) {
				a[i]= 255;
				red = argb[i+1];
				green = argb[i+2];
				blue = argb[i+3];
				p = red*0.3 + green*0.59 + blue*0.11 ; 
				if (red>p*f && green<p && blue<p ) {
					a[i+1] = 0;
					a[i+2] = 0;
					a[i+3] = 255;
				}
				else {
					a[i+1] = p;
					a[i+2] = p;
					a[i+3] = p;
				}
			}
			return a;
		}

		//Recursive 4-way floodfill, crashes if recursion stack is full 
		public function floodFill4(start:int):void { 
			// derived from http://www.student.kuleuven.be/~m0216922/CG/floodfill.html#Recursive_Scanline_Floodfill_Algorithm
		  //  if(x >= 0 && x < w && y >= 0 && y < h && screenBuffer[x][y] == oldColor && screenBuffer[x][y] != newColor) 
		    if(start >= 0 && start <= width*height && floodFillResult[start] != true) { 
		    { 
		        screenBuffer[x][y] = newColor; //set color before starting recursion
		        
		        floodFill4(x + 1, y,     newColor, oldColor);
		        floodFill4(x - 1, y,     newColor, oldColor);
		        floodFill4(x,     y + 1, newColor, oldColor);
		        floodFill4(x,     y - 1, newColor, oldColor);
		    }     
		}							
		
		public function findBlobStart(x:int, y:int, w:int, h:int, bar:ByteArray):Array {
			width = w;
			height = h;
			convertToGrey(bar);
			var blob:Array = new Array(); 
			var start:int = x + y*width; 
			var result:Array = [0,0,0,0,0,0];
			var threshhold:int = parr[start]*threshholdMult;
			lastThreshhold = threshhold;
			var i:int;
			for (i=0;i<parr.length;i++){
				if (parr[i]>threshhold) { parr[i]=true; }
				else { parr[i]=false; }
			}
			blob[start]=true;	
			for (i=start; i<parr.length; i++) { //start to end
				// below wraps blob, doesn't check if right on screen edge, but seems to work 
				if (parr[i] && (blob[i-1] || blob[i+1] || blob[i-width] || blob[i+width])){
					blob[i]=true;
				}
			}
			/*
			for (i=start; i>=0; i--) { // end to start
				if (parr[i] && (blob[i-1] || blob[i+1] || blob[i-width] || blob[i+width])){
					blob[i]=true;
				}
			}
			*/
			for (i=0; i<=width*height; i++) { // another pass, zero to end
				if (parr[i] && (blob[i-1] || blob[i+1] || blob[i-width] || blob[i+width])){
					blob[i]=true;
				}
			}
			for (i=width*height; i>=0; i--) { //end to zero
				if (parr[i] && (blob[i-1] || blob[i+1] || blob[i-width] || blob[i+width])){
					blob[i]=true;
				}
			}
			if (blob.length>1) { // error, its always greater than 1!!  should be 'contains at least one TRUE'? or just remove condition
				result =  blobResult(blob,start);
			}
			lastblob=blob.slice(); // maybe only for development, remove if unnceccessary
			return result;
		}
		
		public function findBlobs(bar:ByteArray, w:int, h:int):Array {
			width = w;
			height = h;
			var blobs:Array=new Array();
			var result:Array = [0,0,0,0,0,0];
			//var imgaverageOld:int = imgaverage;
			convertToGrey(bar);
			var threshhold:int = lastThreshhold;//*imgaverage/imgaverageOld; //could make this better by averaging the previous blob
			var i:int;
			var totalBlobsPixelsCount:int = 0;
			for (i=0; i<parr.length; i++){
				if (parr[i]>threshhold) { 
					parr[i]=true;
					totalBlobsPixelsCount++;
				}
				else { parr[i]=false; }
			}
			var parrhit:Array = parr.slice();
			var blobnum:int = 0;
			var totalBlobsPixelsCounted:int = 0;
			var maxdiff:Number = 999999999;
			var diff:Number;
			var winner:int =-1;
			var winnerBlobSize:int; 
			var winRect:Array;
			var winnerTopRatio:Number;
			var winnerBlobRatio:Number;
			var winnerBottomRatio:Number;
			var lastEqTrue:int;
			var minx:int;
			var miny:int;
			var maxx:int;
			var maxy:int; 
			var topRatio:Number;
			var blobRatio:Number;
			var bottomRatio:Number;
			var blobSize:int;
			var r:Array;
			while (totalBlobsPixelsCounted < totalBlobsPixelsCount) {
				blobs[blobnum] = [];
				for (i=0; i<=width*height; i++) { // zero to end
					if (parrhit[i] && (blobs[blobnum].length==0 || blobs[blobnum][i-1] || blobs[blobnum][i+1] ||
							 blobs[blobnum][i-width] || blobs[blobnum][i+width])){
						parrhit[i]=false;
						blobs[blobnum][i]=true;
						totalBlobsPixelsCounted++;
						lastEqTrue = i;
					}
				}
				for (i=width*height; i>=0; i--) { // end to zero
					if (parrhit[i] && (blobs[blobnum].length==0 || blobs[blobnum][i-1] || blobs[blobnum][i+1] ||
							 blobs[blobnum][i-width] || blobs[blobnum][i+width])){
						parrhit[i]=false;
						blobs[blobnum][i]=true;
						totalBlobsPixelsCounted++;
						lastEqTrue = i;
					}
				}

				r = getRect(blobs[blobnum],lastEqTrue); 
				blobSize = r[4];
				if (blobSize > 75) { // discard tiny blobs
					minx = r[0];
					maxx = r[1];
					miny = r[2];
					maxy = r[3];  
					topRatio = getPixelEqTrueCount(blobs[blobnum], minx, maxx, miny, miny+(maxy-miny)*0.333) / blobSize;
					bottomRatio = getPixelEqTrueCount(blobs[blobnum], minx, maxx, miny+(maxy-miny)*0.666, maxy) / blobSize;
					blobRatio = (maxx-minx)/(maxy-miny);
					diff = Math.abs(topRatio - lastTopRatio) + Math.abs(bottomRatio- lastBottomRatio);
					 // ABOVE WORKING GOOD -- could add multiplier based on aspect ratio, to make it comp better for angles (but that favours others too?)
					//diff = diff * (blobRatio/lastBlobRatio); // blobRatio should be <= last, if calibrated face on
					if (diff < maxdiff && blobRatio < 1.1) {
						winner=blobnum;
						winnerBlobSize = r[4];
						maxdiff = diff;
						winRect = r.slice();
						winnerTopRatio = topRatio;
						winnerBottomRatio = bottomRatio;
						winnerBlobRatio = blobRatio;
					}
				} //size condition end bracket

				blobnum++;
			}
			
			if (winner != -1) {
				//Lower 3rd, left
				minx = winRect[0];
				maxx = winRect[1];
				miny = winRect[2];
				maxy = winRect[3];  
				var midLeftPixls:int = getPixelEqTrueCount(blobs[winner], minx, minx+(maxx-minx)/2, miny+(maxy-miny)*0.333, miny+(maxy-miny)*0.666);
				var midRightPixls:int = getPixelEqTrueCount(blobs[winner], minx+(maxx-minx)/2+1, maxx, miny+(maxy-miny)*0.333, miny+(maxy-miny)*0.666);
				
				trace("winner=> top:"+winnerTopRatio+", bot:"+ winnerBottomRatio+", blob:"+winnerBlobRatio+", numblobs:"+(blobnum-1)+", diff:"+maxdiff);
				lastblob=blobs[winner].slice(); // only for development (to display bitmap), remove if unnceccessary
				result = [minx,miny,maxx-minx+1,maxy-miny+1,midLeftPixls,midRightPixls]; //x,y,width,height,midLeftPixls, midRightPixls
			}
			return result;
		}
		
		private function getRect(blob:Array, start:int):Array {
			var y:int = start/width;
			var x:int = start - (y*width); 	
			var minx:int = x;
			var miny:int = y;
			var maxx:int = x;
			var maxy:int = y;
			var p:int;
			var tempy:int 
			var tempx:int
			var size:int = 0;
			for (p=0; p<width*height; p++) {
				if (blob[p]) {
					tempy = p/width;
					tempx = p - (tempy*width); 
					if (tempx < minx) { minx = tempx; }
					if (tempx > maxx) { maxx = tempx; }
					if (tempy < miny) { miny = tempy; }
					if (tempy > maxy) { maxy = tempy; }
					size++;
				}
			}
			var result:Array=[minx,maxx,miny,maxy,size];
			return result;
		}
		
		private function getPixelEqTrueCount(blob:Array,startx:int,endx:int,starty:int,endy:int):int {
			var result:int = 0;
			for (var yy:int = starty; yy<endy; yy++) {
				for (var xx:int = startx; xx<=endx; xx++) {
					if (blob[yy*width + xx]) {
						result++;
					}
				}
			}
			return result;
		}
		
		private function blobResult(blob:Array, start:int):Array {
			var r:Array = getRect(blob,start);
			var minx:int = r[0];
			var maxx:int = r[1];
			var miny:int = r[2];
			var maxy:int = r[3];  
			lastblobSize = r[4];
			lastTopRatio = getPixelEqTrueCount(blob, minx, maxx, miny, miny+(maxy-miny)*0.333) / lastblobSize;
			lastBottomRatio = getPixelEqTrueCount(blob, minx, maxx, miny+(maxy-miny)*0.666, maxy) / lastblobSize;
			lastBlobRatio = (maxx-minx)/(maxy-miny);
			var midLeftPixls:int = getPixelEqTrueCount(blob, minx, (maxx-minx)/2, miny+(maxy-miny)*0.333, miny+(maxy-miny)*0.666);
			var midRightPixls:int = getPixelEqTrueCount(blob, (maxx-minx)/2+1, maxx, (maxy-miny)*0.333, (maxy-miny)*0.666);
			trace("start=> top:"+lastTopRatio+", bot:"+ lastBottomRatio+", blob:"+lastBlobRatio);
			var result:Array = [minx,miny,maxx-minx+1,maxy-miny+1,midLeftPixls,midRightPixls]; //x,y,width,height,midLeftPixls, midRightPixls
			return result; 
		}		
	}
}